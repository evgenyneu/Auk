//
// An image slideshow for iOS written in Swift.
//
// https://github.com/evgenyneu/Auk
//
// This file was automatically generated by combining multiple Swift source files.
//


// ----------------------------
//
// Auk.swift
//
// ----------------------------

import UIKit

/**

Shows images in the scroll view with page indicator.
Auk extends UIScrollView class by creating the auk property that you can use for showing images.

Usage:

    // Show remote image
    scrollView.auk.show(url: "http://site.com/bird.jpg")

    // Show local image
    if let image = UIImage(named: "bird.jpg") {
      scrollView.auk.show(image: image)
    }

*/
public class Auk {

  // ---------------------------------
  //
  // MARK: - Public interface
  //
  // ---------------------------------

  /**

  Settings that control appearance of the images and page indicator.

  */
  public var settings = AukSettings()
  
    
  /**

  Shows a local image in the scroll view.

  - parameter image: Image to be shown in the scroll view.
  - parameter accessibilityLabel: Text describing the image that will be spoken in accessibility mode. For example: "Picture of a pony standing in a flower pot.".

  */
  public func show(image: UIImage, accessibilityLabel: String? = nil) {
    setup()
    let page = createPage(accessibilityLabel)
    page.show(image: image, settings: settings)
  }

  /**

  Downloads a remote image and adds it to the scroll view. Use `Moa.settings.cache` property to configure image caching.

  - parameter url: Url of the image to be shown.
  - parameter accessibilityLabel: Text describing the image that will be spoken in accessibility mode. For example: "Picture of a pony standing in a flower pot.".

  */
  public func show(url: String, accessibilityLabel: String? = nil) {
    setup()
    let page = createPage(accessibilityLabel)
    page.show(url: url, settings: settings)

    if let scrollView = scrollView,
      currentPageIndex = currentPageIndex {
      
      AukPageVisibility.tellPagesAboutTheirVisibility(scrollView, settings: settings,
                                                      currentPageIndex: currentPageIndex)
    }
  }
  
  /**
   
   Replaces an image on a given page.
   
   - parameter pageIndex: the index of the image to change. Does nothing if the index is less than zero ir greater than the largest index.
   - parameter image: Image to be shown in the scroll view.
   - parameter accessibilityLabel: Text describing the image that will be spoken in accessibility mode.
   For example: "Picture of a pony standing in a flower pot.".
   
   */
  public func updateAt(_ pageIndex:Int, image: UIImage, accessibilityLabel: String? = nil) {
    if let scrollView = scrollView,
      page = AukScrollViewContent.pageAt(pageIndex, scrollView: scrollView) {
      
      page.prepareForReuse()
      page.accessibilityLabel = accessibilityLabel
      page.show(image: image, settings: settings)
    }
  }
  
  /**
   
   Downloads an image and uses it to replace an image on a given page. The current image is replaced when the new image has finished downloading. Use `Moa.settings.cache` property to configure image caching.
   
   - parameter pageIndex: the index of the image to change. Does nothing if the index is less than zero ir greater than the largest index.
   - parameter url: Url of the image to be shown.
   - parameter accessibilityLabel: Text describing the image that will be spoken in accessibility mode.
   For example: "Picture of a pony standing in a flower pot.".
   
   */
  public func updateAt(_ pageIndex: Int, url: String, accessibilityLabel: String? = nil) {
    if let scrollView = scrollView,
      page = AukScrollViewContent.pageAt(pageIndex, scrollView: scrollView) {
      
      var updateSettings = settings
      
      // Use current image as a placeholder in order to avoid abrupt change
      // while the new one is being downloaded
      if let currentImage = page.imageView?.image {
          updateSettings.placeholderImage = currentImage
      }
      
      page.prepareForReuse()
      page.accessibilityLabel = accessibilityLabel
      page.show(url: url, settings: updateSettings)
      
      if let currentPageIndex = currentPageIndex {
        AukPageVisibility.tellPagesAboutTheirVisibility(scrollView, settings: settings,
                                                      currentPageIndex: currentPageIndex)
      }
    }
  }

  /**

  Changes the current page.

  - parameter pageIndex: Index of the page to show.
  - parameter animated: The page change will be animated when `true`.

  */
  public func scrollTo(_ pageIndex: Int, animated: Bool) {
    if let scrollView = scrollView {
      AukScrollTo.scrollTo(scrollView, pageIndex: pageIndex, animated: animated,
        numberOfPages: numberOfPages)
    }
  }

  /**

  Changes both the current page and the page width.

  This function can be used for animating the scroll view content during orientation change. It is called in viewWillTransitionToSize and inside animateAlongsideTransition animation block.

      override func viewWillTransitionToSize(size: CGSize,
        withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) {

        super.viewWillTransitionToSize(size, withTransitionCoordinator: coordinator)

          let pageIndex = scrollView.auk.pageIndex

          coordinator.animateAlongsideTransition({ [weak self] _ in
          self?.scrollView.auk.changePage(pageIndex, pageWidth: size.width, animated: false)
        }, completion: nil)
      }

  More information: https://github.com/evgenyneu/Auk/wiki/Size-animation

  - parameter toPageIndex: Index of the page that will be made a current page.
  - parameter pageWidth: The new page width.
  - parameter animated: The page change will be animated when `true`.

  */
  public func scrollTo(_ pageIndex: Int, pageWidth: CGFloat, animated: Bool) {
    if let scrollView = scrollView {
      AukScrollTo.scrollTo(scrollView, pageIndex: pageIndex, pageWidth: pageWidth,
        animated: animated, numberOfPages: numberOfPages)
    }
  }

  /**

  Scrolls to the next page.

  */
  public func scrollToNextPage() {
    scrollToNextPage(cycle: true, animated: true)
  }

  /**

  Scrolls to the next page.

  - parameter cycle: If `true` it scrolls to the first page from the last one. If `false` the scrolling stops at the last page.
  - parameter animated: The page change will be animated when `true`.

  */
  public func scrollToNextPage(cycle: Bool, animated: Bool) {
    if let scrollView = scrollView, currentPageIndex = currentPageIndex {
      AukScrollTo.scrollToNextPage(scrollView, cycle: cycle, animated: animated,
        currentPageIndex: currentPageIndex, numberOfPages: numberOfPages)
    }
  }

  /**

  Scrolls to the previous page.

  */
  public func scrollToPreviousPage() {
    scrollToPreviousPage(cycle: true, animated: true)
  }

  /**

  Scrolls to the previous page.

  - parameter cycle: If true it scrolls to the last page from the first one. If false the scrolling stops at the first page.
  - parameter animated: The page change will be animated when `true`.

  */
  public func scrollToPreviousPage(cycle: Bool, animated: Bool) {
    if let scrollView = scrollView, currentPageIndex = currentPageIndex {
      AukScrollTo.scrollToPreviousPage(scrollView, cycle: cycle, animated: animated,
        currentPageIndex: currentPageIndex, numberOfPages: numberOfPages)
    }
  }

  /**

  Removes all images from the scroll view.

  */
  public func removeAll() {
    if let scrollView = scrollView {
      let pages = AukScrollViewContent.aukPages(scrollView)

      for page in pages {
        page.removeFromSuperview()
      }
    }

    pageIndicatorContainer?.updateNumberOfPages(numberOfPages)
    
    if let currentPageIndex = currentPageIndex {
      pageIndicatorContainer?.updateCurrentPage(currentPageIndex)
    }
  }

  /// Returns the current number of pages.
  public var numberOfPages: Int {
    if let scrollView = scrollView {
      return AukScrollViewContent.aukPages(scrollView).count
    }

    return 0
  }
  
  /// Returns array of currently visible images. Placeholder images are not returned here.
  public var images: [UIImage] {
    guard let scrollView = scrollView else { return [] }
    
    var images = [UIImage]()
    
    for page in AukScrollViewContent.aukPages(scrollView) {
      if let image = page.imageView?.image {
        images.append(image)
      }
    }
    
    return images
  }

  /**

  Returns the current page index. If pages are being scrolled and there are two of them on screen the page index will indicate the page that occupies bigger portion of the screen at the moment. Returns nil if there are no pages. If scrolled way to the left or right beyond the pages it will return zero or the last index respectively.

  */
  public var currentPageIndex: Int? {
    if numberOfPages == 0 { return nil }
    
    if let scrollView = scrollView {
      let width = Double(scrollView.bounds.size.width)
      let offset = Double(scrollView.contentOffset.x)
      
      if width == 0 {
        print("Auk WARNING: scroll view has zero width.")
        return nil
      }
      
      var value = Int(round(offset / width))
      
      // Page # 0 is the rightmost in the right-to-left language layout
      if RightToLeft.isRightToLeft(scrollView) {
        value = numberOfPages - value - 1
      }
      
      if value < 0 { value = 0 }
      if value > numberOfPages - 1 { value = numberOfPages - 1 }
      
      return value
    }

    return nil
  }

  /**

  Starts auto scrolling of the pages with the given delay in seconds. Auto scrolling stops when the user starts scrolling manually.

  - parameter delaySeconds: Amount of time in second each page is visible before scrolling to the next.

  */
  public func startAutoScroll(delaySeconds: Double) {
    startAutoScroll(delaySeconds: delaySeconds, forward: true,
      cycle: true, animated: true)
  }

  /**

  Starts auto scrolling of the pages with the given delay in seconds.

  - parameter delaySeconds: Amount of time in second each page is visible before scrolling to the next.
  - parameter forward: When true the scrolling is done from left to right direction.
  - parameter cycle: If true it scrolls to the first page from the last one. If false the scrolling stops at the last page.
  - parameter animated: The page change will be animated when `true`.

  */
  public func startAutoScroll(delaySeconds: Double, forward: Bool,
    cycle: Bool, animated: Bool) {

    if let scrollView = scrollView {
      autoscroll.startAutoScroll(scrollView, delaySeconds: delaySeconds,
        forward: forward, cycle: cycle, animated: animated, auk: self)
    }
  }

  /**

  Stops auto scrolling of the pages.

  */
  public func stopAutoScroll() {
    autoscroll.stopAutoScroll()
  }

  // ---------------------------------
  //
  // MARK: - Internal functionality
  //
  // ---------------------------------

  var scrollViewDelegate = AukScrollViewDelegate()
  var pageIndicatorContainer: AukPageIndicatorContainer?
  var autoscroll = AukAutoscroll()
  private weak var scrollView: UIScrollView?

  init(scrollView: UIScrollView) {
    self.scrollView = scrollView

    scrollViewDelegate.onScroll = { [weak self] in
      self?.onScroll()
    }

    // We stop auto scrolling when the user starts scrolling manually
    scrollViewDelegate.onScrollByUser = { [weak self] in
      self?.stopAutoScroll()
    }

    scrollViewDelegate.delegate = scrollView.delegate
    scrollView.delegate = scrollViewDelegate
  }

  func setup() {
    createPageIdicator()
    scrollView?.showsHorizontalScrollIndicator = settings.showsHorizontalScrollIndicator
    scrollView?.isPagingEnabled = settings.pagingEnabled
  }
    
  /// Create a page, add it to the scroll view content and layout.
  private func createPage(_ accessibilityLabel: String? = nil) -> AukPage {
    let page = AukPage()
    page.clipsToBounds = true
    page.makeAccessible(accessibilityLabel)

    if let scrollView = scrollView {
      // Pages are added to the left of the current page
      // in the right-to-left language layout.
      // So we need to increase content offset to keep the current page visible.
      if RightToLeft.isRightToLeft(scrollView) && numberOfPages > 0 {
        scrollView.contentOffset.x += scrollView.bounds.size.width
      }
      
      scrollView.addSubview(page)

      AukScrollViewContent.layout(scrollView)
    }

    pageIndicatorContainer?.updateNumberOfPages(numberOfPages)
    
    if let currentPageIndex = currentPageIndex {
      pageIndicatorContainer?.updateCurrentPage(currentPageIndex)
    }

    return page
  }

  func onScroll() {
    if let scrollView = scrollView,
      currentPageIndex = currentPageIndex {
      AukPageVisibility.tellPagesAboutTheirVisibility(scrollView, settings: settings,
                                                      currentPageIndex: currentPageIndex)
      
      pageIndicatorContainer?.updateCurrentPage(currentPageIndex)
    }
  }

  private func createPageIdicator() {
    if !settings.pageControl.visible { return }
    if pageIndicatorContainer != nil { return } // Already created a page indicator container

    if let scrollView = scrollView,
      superview = scrollView.superview {

      let container = AukPageIndicatorContainer()
      container.didTapPageControlCallback = didTapPageControl
      superview.insertSubview(container, aboveSubview: scrollView)
      pageIndicatorContainer = container
      container.setup(settings, scrollView: scrollView)
    }
  }
  
  private func didTapPageControl(_ pageIndex: Int) {
    scrollTo(pageIndex, animated: true)
  }
}


// ----------------------------
//
// AukAutoscroll.swift
//
// ----------------------------

import UIKit

/**

Starts and cancels the auto scrolling.

*/
struct AukAutoscroll {
  var autoscrollTimer: AutoCancellingTimer?
  
  mutating func startAutoScroll(_ scrollView: UIScrollView, delaySeconds: Double,
    forward: Bool, cycle: Bool, animated: Bool, auk: Auk) {
      
    // Assign the new instance of AutoCancellingTimer to autoscrollTimer
    // The previous instance deinitializes and cancels its timer.
      
    autoscrollTimer = AutoCancellingTimer(interval: delaySeconds, repeats: true) {
      guard let currentPageIndex = auk.currentPageIndex else { return }
      
      if forward {
        AukScrollTo.scrollToNextPage(scrollView, cycle: cycle,
          animated: animated, currentPageIndex: currentPageIndex,
          numberOfPages: auk.numberOfPages)
      } else {
        AukScrollTo.scrollToPreviousPage(scrollView, cycle: cycle,
          animated: animated, currentPageIndex: currentPageIndex,
          numberOfPages: auk.numberOfPages)
      }
    }
  }
  
  mutating func stopAutoScroll() {
    autoscrollTimer = nil // Cancels the timer on deinit
  }
}


// ----------------------------
//
// AukPage.swift
//
// ----------------------------

import UIKit

/// The view for an individual page of the scroll view containing an image.
final class AukPage: UIView {
  
  // Image view for showing a placeholder image while remote image is being downloaded.
  // The view is only created when a placeholder image is specified in settings.
  weak var placeholderImageView: UIImageView?

  // Image view for showing local and remote images
  weak var imageView: UIImageView?
  
  // Contains a URL for the remote image, if any.
  var remoteImage: AukRemoteImage?
  
  /**
  
  Shows an image.
  
  - parameter image: The image to be shown
  - parameter settings: Auk settings.
  
  */
  func show(image: UIImage, settings: AukSettings) {
    imageView = createAndLayoutImageView(settings)
    imageView?.image = image
  }
  
  /**
  
  Shows a remote image. The image download stars if/when the page becomes visible to the user.
  
  - parameter url: The URL to the image to be displayed.
  - parameter settings: Auk settings.
  
  */
  func show(url: String, settings: AukSettings) {
    if settings.placeholderImage != nil {
      placeholderImageView = createAndLayoutImageView(settings)
    }
        
    imageView = createAndLayoutImageView(settings)
    
    if let imageView = imageView {
      remoteImage = AukRemoteImage()
      remoteImage?.setup(url, imageView: imageView, placeholderImageView: placeholderImageView,
        settings: settings)
    }
  }
  
  /**

  Called when the page is currently visible to user which triggers the image download. The function is called frequently each time scroll view's content offset is changed.
  
  */
  func visibleNow(_ settings: AukSettings) {
    remoteImage?.downloadImage(settings)
  }
  
  /**
  
  Called when the page is currently not visible to user which cancels the image download. The method called frequently each time scroll view's content offset is changed and the page is out of sight.
  
  */
  func outOfSightNow() {
    remoteImage?.cancelDownload()
  }
     
  /// Removes image views.
  func removeImageViews() {
    placeholderImageView?.removeFromSuperview();
    placeholderImageView = nil
    
    imageView?.removeFromSuperview()
    imageView = nil
  }
  
  /**
  
  Prepares the page view for reuse. Clears current content from the page and stops download.
   
  */
  func prepareForReuse() {
    removeImageViews()
    remoteImage?.cancelDownload()
    remoteImage = nil
  }
    
  /**
  
  Create and layout the remote image view.
  
  - parameter settings: Auk settings.
  
  */
  func createAndLayoutImageView(_ settings: AukSettings) -> UIImageView {
    let newImageView = AukPage.createImageView(settings)
    addSubview(newImageView)
    AukPage.layoutImageView(newImageView, superview: self)
    return newImageView
  }
  
  private static func createImageView(_ settings: AukSettings) -> UIImageView {
    let newImageView = UIImageView()
    newImageView.contentMode = settings.contentMode
    return newImageView
  }
  
  /**
  
  Creates Auto Layout constrains for the image view.
  
  - parameter imageView: Image view that is used to create Auto Layout constraints.
  
  */
  private static func layoutImageView(_ imageView: UIImageView, superview: UIView) {
    imageView.translatesAutoresizingMaskIntoConstraints = false
    
    iiAutolayoutConstraints.fillParent(imageView, parentView: superview, margin: 0, vertically: false)
    iiAutolayoutConstraints.fillParent(imageView, parentView: superview, margin: 0, vertically: true)
  }
  
  func makeAccessible(_ accessibilityLabel: String?) {
    isAccessibilityElement = true
    accessibilityTraits = UIAccessibilityTraitImage
    self.accessibilityLabel = accessibilityLabel
  }
}


// ----------------------------
//
// AukPageIndicatorContainer.swift
//
// ----------------------------

import UIKit

/// View containing a UIPageControl object that shows the dots for present pages.
final class AukPageIndicatorContainer: UIView {
  
  deinit {
    pageControl?.removeTarget(self, action: #selector(AukPageIndicatorContainer.didTapPageControl(_:)),
      for: UIControlEvents.valueChanged)
  }
  
  var didTapPageControlCallback: ((Int)->())?
  
  var pageControl: UIPageControl? {
    get {
      if subviews.count == 0 { return nil }
      return subviews[0] as? UIPageControl
    }
  }
  
  // Layouts the view, creates and layouts the page control
  func setup(_ settings: AukSettings, scrollView: UIScrollView) {    
    styleContainer(settings)
    AukPageIndicatorContainer.layoutContainer(self, settings: settings, scrollView: scrollView)
    
    let pageControl = createPageControl(settings)
    AukPageIndicatorContainer.layoutPageControl(pageControl, superview: self, settings: settings)
    
    updateVisibility()
  }
  
  // Update the number of pages showing in the page control
  func updateNumberOfPages(_ numberOfPages: Int) {
    pageControl?.numberOfPages = numberOfPages
    updateVisibility()
  }
  
  // Update the current page in the page control
  func updateCurrentPage(_ currentPageIndex: Int) {
    pageControl?.currentPage = currentPageIndex
  }
  
  private func styleContainer(_ settings: AukSettings) {
    backgroundColor = settings.pageControl.backgroundColor
    layer.cornerRadius = CGFloat(settings.pageControl.cornerRadius)
  }
  
  private static func layoutContainer(_ pageIndicatorContainer: AukPageIndicatorContainer,
    settings: AukSettings, scrollView: UIScrollView) {
      
    if let superview = pageIndicatorContainer.superview {
      pageIndicatorContainer.translatesAutoresizingMaskIntoConstraints = false
        
      // Align bottom of the page view indicator with the bottom of the scroll view
      iiAutolayoutConstraints.alignSameAttributes(pageIndicatorContainer, toItem: scrollView,
        constraintContainer: superview, attribute: NSLayoutAttribute.bottom,
        margin: CGFloat(-settings.pageControl.marginToScrollViewBottom))
      
      // Center the page view indicator horizontally in relation to the scroll view
      iiAutolayoutConstraints.alignSameAttributes(pageIndicatorContainer, toItem: scrollView,
        constraintContainer: superview, attribute: NSLayoutAttribute.centerX, margin: 0)
    }
  }
  
  private func createPageControl(_ settings: AukSettings) -> UIPageControl {
    let pageControl = UIPageControl()
    
    if #available(*, iOS 9.0) {
      // iOS 9+
    } else {
      // When using right-to-left language, flip the page control horizontally in iOS 8 and earlier.
      // That will make it highlight the rightmost dot for the first page.
      if RightToLeft.isRightToLeft(self) {
        pageControl.transform = CGAffineTransform(scaleX: -1, y: 1)
      }
    }
    
    pageControl.addTarget(self, action: #selector(AukPageIndicatorContainer.didTapPageControl(_:)),
      for: UIControlEvents.valueChanged)
    
    pageControl.pageIndicatorTintColor = settings.pageControl.pageIndicatorTintColor
    pageControl.currentPageIndicatorTintColor = settings.pageControl.currentPageIndicatorTintColor

    addSubview(pageControl)
    return pageControl
  }
  
  func didTapPageControl(_ control: UIPageControl) {
    if let currentPage = pageControl?.currentPage {
      didTapPageControlCallback?(currentPage)
    }
  }
  
  private static func layoutPageControl(_ pageControl: UIPageControl, superview: UIView,
    settings: AukSettings) {
      
    pageControl.translatesAutoresizingMaskIntoConstraints = false
    
    iiAutolayoutConstraints.fillParent(pageControl, parentView: superview,
      margin: settings.pageControl.innerPadding.width, vertically: false)
    
    iiAutolayoutConstraints.fillParent(pageControl, parentView: superview,
      margin: settings.pageControl.innerPadding.height, vertically: true)
  }
  
  private func updateVisibility() {
    self.isHidden = pageControl?.numberOfPages < 2
  }
}


// ----------------------------
//
// AukPageVisibility.swift
//
// ----------------------------

import UIKit

/**

Helper functions that tell if the scroll view page is currently visible to the user.

*/
struct AukPageVisibility {
  /**
  
  Check if the given page is currently visible to user.
  
  - parameter scrollView: Scroll view containing the page.
  - parameter page: A scroll view page which visibility will be checked.
  
  - returns: True if the page is visible to the user.
  
  */
  static func isVisible(_ scrollView: UIScrollView, page: AukPage) -> Bool {
    return scrollView.bounds.intersects(page.frame)
  }
  
  /**
  
  Tells if the page is way out of sight. This is done to prevent cancelling download of the image for the page that is not very far out of sight.
  
  - parameter scrollView: Scroll view containing the page.
  - parameter page: A scroll view page which visibility will be checked.
  
  - returns: True if the page is visible to the user.
  
  */
  static func isFarOutOfSight(_ scrollView: UIScrollView, page: AukPage) -> Bool {
    let parentRectWithIncreasedHorizontalBounds = scrollView.bounds.insetBy(dx: -50, dy: 0)
    return !parentRectWithIncreasedHorizontalBounds.intersects(page.frame)
  }
  
  /**
  
  Goes through all the scroll view pages and tell them if they are visible or out of sight. The pages, in turn, if they are visible start the download of the image or cancel the download if they are out of sight.
  
  - parameter scrollView: Scroll view with the pages.

  */
  static func tellPagesAboutTheirVisibility(_ scrollView: UIScrollView,
                                            settings: AukSettings,
                                            currentPageIndex: Int) {
    
    let pages = AukScrollViewContent.aukPages(scrollView)

    for (index, page) in pages.enumerated() {
      if isVisible(scrollView, page: page) {
        page.visibleNow(settings)
      } else {
        if abs(index - currentPageIndex) <= settings.preloadRemoteImagesAround {
          // Preload images for the pages around the current page
          page.visibleNow(settings)
        } else {
          /*
          The image is not visible to user and is not preloaded - cancel its download.
           
          Now, this is a bit nuanced so let me explain. When we scroll into a new page we sometimes see a little bit of the next page. The scroll view animation overshoots a little bit to show the next page and then slides back to the current page. This is probably done on purpose for more natural spring bouncing effect.

          When the scroll view overshoots and shows the next page, we call `isVisible` on it and it starts downloading its image. But because scroll view bounces back in a moment the page becomes invisible again very soon. If we just call `outOfSightNow()` the next page download will be canceled even though it has just been started. That is probably not very efficient use of network, so we call `isFarOutOfSight` function to check if the next page is way out of sight (and not just a little bit). If the page is out of sight but just by a little margin we still let it download the image.

          */
          if isFarOutOfSight(scrollView, page: page) {
            page.outOfSightNow()
          }
        }
      }
    }
  }
}


// ----------------------------
//
// AukRemoteImage.swift
//
// ----------------------------

import UIKit

/**

Downloads and shows a single remote image.

*/
class AukRemoteImage {
  var url: String?
  weak var imageView: UIImageView?
  weak var placeholderImageView: UIImageView?

  init() { }

  /// True when image has been successfully downloaded
  var didFinishDownload = false

  func setup(_ url: String, imageView: UIImageView, placeholderImageView: UIImageView?,
    settings: AukSettings) {

    self.url = url
    self.imageView = imageView
    self.placeholderImageView = placeholderImageView
    setPlaceholderImage(settings)
  }

  /// Sends image download HTTP request.
  func downloadImage(_ settings: AukSettings) {
    if imageView?.moa.url != nil { return } // Download has already started
    if didFinishDownload { return } // Image has already been downloaded

    imageView?.moa.errorImage = settings.errorImage

    imageView?.moa.onSuccessAsync = { [weak self] image in
      self?.didReceiveImageAsync(image, settings: settings)
      return image
    }

    imageView?.moa.url = url
  }

  /// Cancel current image download HTTP request.
  func cancelDownload() {
    // Cancel current download by setting url to nil
    imageView?.moa.url = nil
  }

  func didReceiveImageAsync(_ image: UIImage, settings: AukSettings) {
    didFinishDownload = true

    iiQ.main { [weak self] in
      guard let imageView = self?.imageView else { return }
      AukRemoteImage.animateImageView(imageView, show: true, settings: settings)
    
      if let placeholderImageView = self?.placeholderImageView {
        AukRemoteImage.animateImageView(placeholderImageView, show: false, settings: settings)
      }
    }
  }

  private static func animateImageView(_ imageView: UIImageView, show: Bool, settings: AukSettings) {
    imageView.alpha = show ? 0: 1
    let interval = TimeInterval(settings.remoteImageAnimationIntervalSeconds)
    
    UIView.animate(withDuration: interval, animations: {
      imageView.alpha = show ? 1: 0
    })
  }
  
  private func setPlaceholderImage(_ settings: AukSettings) {
    if let placeholderImage = settings.placeholderImage,
      placeholderImageView = placeholderImageView {
        
      placeholderImageView.image = placeholderImage
    }
  }
}


// ----------------------------
//
// AukScrollTo.swift
//
// ----------------------------

import UIKit

/**

Scrolling code.

*/
struct AukScrollTo {
  static func scrollTo(_ scrollView: UIScrollView, pageIndex: Int, animated: Bool,
    numberOfPages: Int) {
      
    let pageWidth = scrollView.bounds.size.width
    scrollTo(scrollView, pageIndex: pageIndex, pageWidth: pageWidth, animated: animated,
      numberOfPages: numberOfPages)
  }
  
  static func scrollTo(_ scrollView: UIScrollView, pageIndex: Int, pageWidth: CGFloat,
    animated: Bool, numberOfPages: Int) {
      
    let offsetX = contentOffsetForPage(pageIndex, pageWidth: pageWidth,
      numberOfPages: numberOfPages, scrollView: scrollView)
    
    let offset = CGPoint(x: offsetX, y: 0)
  
    scrollView.setContentOffset(offset, animated: animated)
  }
  
  static func scrollToNextPage(_ scrollView: UIScrollView, cycle: Bool, animated: Bool,
    currentPageIndex: Int, numberOfPages: Int) {
      
    var pageIndex = currentPageIndex + 1
      
    if pageIndex >= numberOfPages {
      if cycle {
        pageIndex = 0
      } else {
        return
      }
    }
    
    scrollTo(scrollView, pageIndex: pageIndex, animated: animated, numberOfPages: numberOfPages)
  }
  
  static func scrollToPreviousPage(_ scrollView: UIScrollView, cycle: Bool, animated: Bool,
    currentPageIndex: Int, numberOfPages: Int) {
    
    var pageIndex = currentPageIndex - 1
      
    if pageIndex < 0 {
      if cycle {
        pageIndex = numberOfPages - 1
      } else {
        return
      }
    }
    
    scrollTo(scrollView, pageIndex: pageIndex, animated: animated, numberOfPages: numberOfPages)
  }
  
  /**

  Returns horizontal content offset needed to display the given page.
  Ensures that offset is within the content size.

  */
  static func contentOffsetForPage(_ pageIndex: Int, pageWidth: CGFloat,
    numberOfPages: Int, scrollView: UIView) -> CGFloat {
      
    // The index of the page that appears from left to right of the screen.
    // It is the same as pageIndex for left-to-right languages.
    let pageIndexFromTheLeft = RightToLeft.isRightToLeft(scrollView) ?
      numberOfPages - pageIndex - 1 : pageIndex
      
    var offsetX = CGFloat(pageIndexFromTheLeft) * pageWidth
      
    let maxOffset = CGFloat(numberOfPages - 1) * pageWidth
    
    // Prevent overscrolling to the right
    if offsetX > maxOffset { offsetX = maxOffset }
    
    // Prevent overscrolling to the left
    if offsetX < 0 { offsetX = 0 }
      
    return offsetX
  }
}


// ----------------------------
//
// AukScrollViewContent.swift
//
// ----------------------------

import UIKit

/**

Collection of static functions that help managing the scroll view content.

*/
struct AukScrollViewContent {
  
  /**

  - returns: Array of scroll view pages.
  
  */
  static func aukPages(_ scrollView: UIScrollView) -> [AukPage] {
    return scrollView.subviews.filter { $0 is AukPage }.map { $0 as! AukPage }
  }
  
  /**
 
  - returns: Page at index. Returns nil if index is out of bounds.
 
  */
  static func pageAt(_ index: Int, scrollView: UIScrollView) -> AukPage? {
    let pages = aukPages(scrollView)
    if index < 0 { return nil }
    if index >= pages.count { return nil }
    return pages[index]
  }
  
  /**
  
  Creates Auto Layout constraints for positioning the page view inside the scroll view.
  
  */
  static func layout(_ scrollView: UIScrollView) {
    let pages = aukPages(scrollView)
    let settings = scrollView.auk.settings
    for (index, page) in pages.enumerated() {
      
      // Delete current constraints by removing the view and adding it back to its superview
      page.removeFromSuperview()
      scrollView.addSubview(page)
      
      page.translatesAutoresizingMaskIntoConstraints = false
      
      // Make page size equal to the scroll view size
      scrollView.addConstraint(NSLayoutConstraint(item: page, attribute: .width, relatedBy: .equal, toItem: scrollView, attribute: .width, multiplier: 1, constant: -settings.horizontalPageMargin * 2))
      iiAutolayoutConstraints.equalHeight(page, viewTwo: scrollView, constraintContainer: scrollView)
      // Stretch the page vertically to fill the height of the scroll view
      iiAutolayoutConstraints.fillParent(page, parentView: scrollView, margin: 0, vertically: true)
      
      if index == 0 {
        // Align the leading edge of the first page to the leading edge of the scroll view.
        iiAutolayoutConstraints.alignSameAttributes(page, toItem: scrollView,
          constraintContainer: scrollView, attribute: NSLayoutAttribute.leading, margin: settings.horizontalPageMargin)
      }
      
      if index == pages.count - 1 {
        // Align the trailing edge of the last page to the trailing edge of the scroll view.
        iiAutolayoutConstraints.alignSameAttributes(page, toItem: scrollView,
          constraintContainer: scrollView, attribute: NSLayoutAttribute.trailing, margin: settings.horizontalPageMargin)
      }
    }
    
    // Align page next to each other
    iiAutolayoutConstraints.viewsNextToEachOther(pages, constraintContainer: scrollView,
      margin: settings.horizontalPageMargin * 2, vertically: false)
    
    scrollView.layoutIfNeeded()
  }
}


// ----------------------------
//
// AukScrollViewDelegate.swift
//
// ----------------------------

import UIKit

/**

This delegate detects the scrolling event which is used for loading remote images when their superview becomes visible on screen.

*/
final class AukScrollViewDelegate: NSObject, UIScrollViewDelegate {
  /**
  
  If scroll view already has delegate it is preserved in this property and all the delegate calls are forwarded to it.
  
  */
  weak var delegate: UIScrollViewDelegate?
  
  var onScroll: (()->())?
  var onScrollByUser: (()->())?
  
  func scrollViewDidScroll(_ scrollView: UIScrollView) {
    onScroll?()
    delegate?.scrollViewDidScroll?(scrollView)
  }
  
  func scrollViewDidZoom(_ scrollView: UIScrollView) {
    delegate?.scrollViewDidZoom?(scrollView)
  }
  
  func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
    delegate?.scrollViewWillBeginDragging?(scrollView)
    onScrollByUser?()
  }
  
  func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
    
    delegate?.scrollViewWillEndDragging?(scrollView, withVelocity: velocity, targetContentOffset: targetContentOffset)
  }
  
  func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
    delegate?.scrollViewDidEndDragging?(scrollView, willDecelerate: decelerate)
  }
  
  func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView) {
    delegate?.scrollViewWillBeginDecelerating?(scrollView)
  }
  
  func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
    delegate?.scrollViewDidEndDecelerating?(scrollView)
  }
  
  func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
    delegate?.scrollViewDidEndScrollingAnimation?(scrollView)
  }
  
  func viewForZooming(in scrollView: UIScrollView) -> UIView? {
    return delegate?.viewForZooming?(in: scrollView)
  }
  
  func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?) {
    delegate?.scrollViewWillBeginZooming?(scrollView, with: view)
  }
  
  func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
    delegate?.scrollViewDidEndZooming?(scrollView, with: view, atScale: scale)
  }
  
  func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool {
    return delegate?.scrollViewShouldScrollToTop?(scrollView) ?? true
  }
  
  func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
    delegate?.scrollViewDidScrollToTop?(scrollView)
  }
}


// ----------------------------
//
// AukSettings.swift
//
// ----------------------------

import UIKit

/**

Appearance and behavior of the scroll view.

*/
public struct AukSettings {
  
  /// Determines the stretching and scaling of the image when its proportion are not the same as its  container.
  public var contentMode = UIViewContentMode.scaleAspectFit
  
  /// Image to be displayed when remote image download fails.
  public var errorImage: UIImage?
  
  /// Settings for styling the scroll view page indicator.
  public var pageControl = PageControlSettings()
  
  /// Enable paging for the scroll view. When true the view automatically scrolls to show the whole image.
  public var pagingEnabled = true
  
  /// Image to be displayed while the remote image is being downloaded.
  public var placeholderImage: UIImage?
  
  /**
   
  The number of remote images to preload around the current page. For example, if preloadRemoteImagesAround = 2 and we are viewing the first page it will preload images on the second and third pages. If we are viewing 5th page then it will preload images on pages 3, 4, 6 and 7 (unless they are already loaded). The default value is 0, i.e. it only loads the image for the currently visible pages.
   
  */
  public var preloadRemoteImagesAround = 0
  
  /// The duration of the animation that is used to show the remote images.
  public var remoteImageAnimationIntervalSeconds: Double = 0.5
  
  /// Show horizontal scroll indicator.
  public var showsHorizontalScrollIndicator = false
  
  /// Horizontal margin on left and right of each page.
  public var horizontalPageMargin : CGFloat = 0
}

/**

Settings for page indicator.

*/
public struct PageControlSettings {
  /// Background color of the page control container view.
  public var backgroundColor = UIColor(red: 128/256, green: 128/256, blue: 128/256, alpha: 0.4)
  
  /// Corner radius of page control container view.
  public var cornerRadius: Double = 13
  
  /// Color of the dot representing for the current page.
  public var currentPageIndicatorTintColor: UIColor? = nil
  
  /// Padding between page indicator and its container
  public var innerPadding = CGSize(width: 10, height: -5)
  
  /// Distance between the bottom of the page control view and the bottom of the scroll view.
  public var marginToScrollViewBottom: Double = 8
  
  /// Color of the page indicator dot.
  public var pageIndicatorTintColor: UIColor? = nil
  
  /// When true the page control is visible on screen.
  public var visible = true
}


// ----------------------------
//
// UIScrollView+Auk.swift
//
// ----------------------------

import UIKit

private var xoAukAssociationKey: UInt8 = 0

/**

Scroll view extension for showing series of images with page indicator.


Usage:

    // Show remote image
    scrollView.auk.show(url: "http://site.com/bird.jpg")

    // Show local image
    if let image = UIImage(named: "bird.jpg") {
      scrollView.auk.show(image: image)
    }

*/
public extension UIScrollView {
  /**
  
  Scroll view extension for showing series of images with page indicator.
  
  Usage:
  
      // Show remote image
      scrollView.auk.show(url: "http://site.com/bird.jpg")
      
      // Show local image
      if let image = UIImage(named: "bird.jpg") {
        scrollView.auk.show(image: image)
      }
  
  */
  public var auk: Auk {
    get {
      if let value = objc_getAssociatedObject(self, &xoAukAssociationKey) as? Auk {
        return value
      } else {
        let auk = Auk(scrollView: self)
        
        objc_setAssociatedObject(self, &xoAukAssociationKey, auk,
          objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
        
        return auk
      }
    }
    
    set {
      objc_setAssociatedObject(self, &xoAukAssociationKey, newValue,
        objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
    }
  }
}


// ----------------------------
//
// AutoCancellingTimer.swift
//
// ----------------------------

//
// Creates a timer that executes code after delay. The timer lives in an instance of `AutoCancellingTimer` class and is automatically canceled when this instance is deallocated.
// This is an auto-canceling alternative to timer created with `dispatch_after` function.
//
// Source: https://gist.github.com/evgenyneu/516f7dcdb5f2f73d
//
// Usage
// -----
//     
//     class MyClass {
//         var timer: AutoCancellingTimer? // Timer will be cancelled with MyCall is deallocated
//
//         func runTimer() {
//             timer = AutoCancellingTimer(interval: delaySeconds, repeats: true) {
//                ... code to run
//             }
//         }
//     }
//
//
//  Cancel the timer
//  --------------------
//
//  Timer is canceled automatically when it is deallocated. You can also cancel it manually:
//
//     timer.cancel()
//

import UIKit

final class AutoCancellingTimer {
  private var timer: AutoCancellingTimerInstance?
  
  init(interval: TimeInterval, repeats: Bool = false, callback: ()->()) {
    timer = AutoCancellingTimerInstance(interval: interval, repeats: repeats, callback: callback)
  }
  
  deinit {
    timer?.cancel()
  }
  
  func cancel() {
    timer?.cancel()
  }
}

final class AutoCancellingTimerInstance: NSObject {
  private let repeats: Bool
  private var timer: Timer?
  private var callback: ()->()
  
  init(interval: TimeInterval, repeats: Bool = false, callback: ()->()) {
    self.repeats = repeats
    self.callback = callback
    
    super.init()
    
    timer = Timer.scheduledTimer(timeInterval: interval, target: self,
      selector: #selector(AutoCancellingTimerInstance.timerFired(_:)), userInfo: nil, repeats: repeats)
  }
  
  func cancel() {
    timer?.invalidate()
  }
  
  func timerFired(_ timer: Timer) {
    self.callback()
    if !repeats { cancel() }
  }
}


// ----------------------------
//
// iiAutolayoutConstraints.swift
//
// ----------------------------

//
//  Collection of shortcuts to create autolayout constraints.
//

import UIKit

class iiAutolayoutConstraints {
  class func fillParent(_ view: UIView, parentView: UIView, margin: CGFloat = 0, vertically: Bool = false) {
    var marginFormat = ""

    if margin != 0 {
      marginFormat = "-(\(margin))-"
    }

    var format = "|\(marginFormat)[view]\(marginFormat)|"

    if vertically {
      format = "V:" + format
    }

    let constraints = NSLayoutConstraint.constraints(withVisualFormat: format,
      options: [], metrics: nil,
      views: ["view": view])

    parentView.addConstraints(constraints)
  }
  
  @discardableResult
  class func alignSameAttributes(_ item: AnyObject, toItem: AnyObject,
    constraintContainer: UIView, attribute: NSLayoutAttribute, margin: CGFloat = 0) -> [NSLayoutConstraint] {
      
    let constraint = NSLayoutConstraint(
      item: item,
      attribute: attribute,
      relatedBy: NSLayoutRelation.equal,
      toItem: toItem,
      attribute: attribute,
      multiplier: 1,
      constant: margin)
    
    constraintContainer.addConstraint(constraint)
    
    return [constraint]
  }

  class func equalWidth(_ viewOne: UIView, viewTwo: UIView, constraintContainer: UIView) -> [NSLayoutConstraint] {
    
    return equalWidthOrHeight(viewOne, viewTwo: viewTwo, constraintContainer: constraintContainer, isHeight: false)
  }
  
  // MARK: - Equal height and width
  @discardableResult
  class func equalHeight(_ viewOne: UIView, viewTwo: UIView, constraintContainer: UIView) -> [NSLayoutConstraint] {
    
    return equalWidthOrHeight(viewOne, viewTwo: viewTwo, constraintContainer: constraintContainer, isHeight: true)
  }
  
  @discardableResult
  class func equalSize(_ viewOne: UIView, viewTwo: UIView, constraintContainer: UIView) -> [NSLayoutConstraint] {
    
    var constraints = equalWidthOrHeight(viewOne, viewTwo: viewTwo, constraintContainer: constraintContainer, isHeight: false)
    
    constraints += equalWidthOrHeight(viewOne, viewTwo: viewTwo, constraintContainer: constraintContainer, isHeight: true)
    
    return constraints
  }
  
  class func equalWidthOrHeight(_ viewOne: UIView, viewTwo: UIView, constraintContainer: UIView,
    isHeight: Bool) -> [NSLayoutConstraint] {
    
    var prefix = ""
    
    if isHeight { prefix = "V:" }
    
    let constraints = NSLayoutConstraint.constraints(withVisualFormat: "\(prefix)[viewOne(==viewTwo)]",
      options: [], metrics: nil,
      views: ["viewOne": viewOne, "viewTwo": viewTwo])
        
    constraintContainer.addConstraints(constraints)
    
    return constraints
  }
  
  // MARK: - Align view next to each other
  
  @discardableResult
  class func viewsNextToEachOther(_ views: [UIView],
    constraintContainer: UIView, margin: CGFloat = 0,
    vertically: Bool = false) -> [NSLayoutConstraint] {
      
    if views.count < 2 { return []  }
    
    var constraints = [NSLayoutConstraint]()
    
    for (index, view) in views.enumerated() {
      if index >= views.count - 1 { break }
      
      let viewTwo = views[index + 1]
      
      constraints += twoViewsNextToEachOther(view, viewTwo: viewTwo,
        constraintContainer: constraintContainer, margin: margin, vertically: vertically)
    }
    
    return constraints
  }
  
  class func twoViewsNextToEachOther(_ viewOne: UIView, viewTwo: UIView,
    constraintContainer: UIView, margin: CGFloat = 0,
    vertically: Bool = false) -> [NSLayoutConstraint] {
      
    var marginFormat = ""
    
    if margin != 0 {
      marginFormat = "-\(margin)-"
    }
    
    var format = "[viewOne]\(marginFormat)[viewTwo]"
    
    if vertically {
      format = "V:" + format
    }
    
    let constraints = NSLayoutConstraint.constraints(withVisualFormat: format,
      options: [], metrics: nil,
      views: [ "viewOne": viewOne, "viewTwo": viewTwo ])
    
    constraintContainer.addConstraints(constraints)
    
    return constraints
  }
  
  @discardableResult
  class func height(_ view: UIView, value: CGFloat) -> [NSLayoutConstraint] {
    return widthOrHeight(view, value: value, isHeight: true)
  }
  
  @discardableResult
  class func width(_ view: UIView, value: CGFloat) -> [NSLayoutConstraint] {
    return widthOrHeight(view, value: value, isHeight: false)
  }
  
  class func widthOrHeight(_ view: UIView, value: CGFloat, isHeight: Bool) -> [NSLayoutConstraint] {
    
    let layoutAttribute = isHeight ? NSLayoutAttribute.height : NSLayoutAttribute.width
    
    let constraint = NSLayoutConstraint(
      item: view,
      attribute: layoutAttribute,
      relatedBy: NSLayoutRelation.equal,
      toItem: nil,
      attribute: NSLayoutAttribute.notAnAttribute,
      multiplier: 1,
      constant: value)
    
    view.addConstraint(constraint)
    
    return [constraint]
  }
}


// ----------------------------
//
// iiQ.swift
//
// ----------------------------

//
//  iiQueue.swift
//
//  Shortcut functions to run code in asynchronously and in main queue
//
//  Created by Evgenii Neumerzhitckii on 11/10/2014.
//  Copyright (c) 2014 Evgenii Neumerzhitckii. All rights reserved.
//

import UIKit

class iiQ {
  class func async(_ block: ()->()) {
    DispatchQueue.global(attributes: DispatchQueue.GlobalAttributes.qosDefault).async(execute: block)
  }

  class func main(_ block: ()->()) {
    DispatchQueue.main.async(execute: block)
  }

  class func runAfterDelay(_ delaySeconds: Double, block: ()->()) {
    let time = DispatchTime.now() + Double(Int64(delaySeconds * Double(NSEC_PER_SEC))) / Double(NSEC_PER_SEC)
    DispatchQueue.main.after(when: time, execute: block)
  }
}


// ----------------------------
//
// RightToLeft.swift
//
// ----------------------------

import UIKit

/**

Helper functions for dealing with right-to-left languages.

*/
struct RightToLeft {
  static func isRightToLeft(_ view: UIView) -> Bool {
    if #available(iOS 9.0, *) {
      return UIView.userInterfaceLayoutDirection(
        for: view.semanticContentAttribute) == .rightToLeft
    } else {
      return UIApplication.shared().userInterfaceLayoutDirection == .rightToLeft
    }
  }
}


